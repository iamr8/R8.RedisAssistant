using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using StackExchange.Redis;

namespace R8.RedisMapper.SourceGenerator
{
    [Generator]
    public class CacheModelSourceGenerator : IIncrementalGenerator
    {
        private string Namespace = $"{nameof(R8)}.{nameof(RedisMapper)}";
        private static readonly List<string> GeneratedTypes = new List<string>();

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // register a syntax receiver that will create source for any class that implements IRedisCacheModel
            var declares = context.SyntaxProvider
                .CreateSyntaxProvider(Predicate, Transform);

            var provider = context.CompilationProvider.Combine(declares.Collect());

            context.RegisterSourceOutput(provider, Execute);
        }

        private void Execute(SourceProductionContext ctx, (Compilation Left, ImmutableArray<INamedTypeSymbol> Right) symbol)
        {
            var (_, namedTypeSymbols) = symbol;
            foreach (var type in namedTypeSymbols)
            {
                var typeFullQualifiedName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (GeneratedTypes.Contains(typeFullQualifiedName, StringComparer.Ordinal))
                    continue;

                var props = GetPropertySymbols(type);
                if (props.Length == 0)
                    continue;

                var resolvedProps = props
                    .Select(propertySymbol =>
                    {
                        var attribute = propertySymbol.GetAttributes().FirstOrDefault(x => x.AttributeClass?.Name.Equals(nameof(RedisFormatterAttribute), StringComparison.Ordinal) == true);
                        var formatterType = attribute?.ConstructorArguments.FirstOrDefault().Value as ITypeSymbol;
                        return new
                        {
                            Name = propertySymbol.Name,
                            Type = propertySymbol.Type,
                            Formatter = formatterType,
                        };
                    })
                    .ToArray();

                var sourceText = SourceText.From($@"// Original source: {typeFullQualifiedName}
// <auto-generated/>
#pragma warning disable 1591

using System;
// using System.Collections.Generic;
using System.Collections.Immutable;
using {Namespace};
using StackExchange.Redis;
// using {type.ContainingNamespace};

namespace {type.ContainingNamespace}
{{
    public partial class {type.Name} : IRedisCacheObjectAdapter<{type.Name}>
    {{
        ImmutableArray<string> IRedisCacheObjectAdapter<{type.Name}>.Properties =>
            new ImmutableArray<string>
            {{
{string.Join('\n', resolvedProps.Select(prop => $"                nameof({type.Name}.{prop.Name}),"))}
            }};
    
        bool IRedisCacheObjectAdapter<{type.Name}>.SetValue({type.Name} instance, string propertyName, RedisValue value)
        {{
            switch (propertyName)
            {{
{string.Join('\n', resolvedProps.Select(prop => $"                case nameof({type.Name}.{prop.Name}): {{ instance.{prop.Name} = {(prop.Formatter != null ? $"{prop.Formatter + $".Instance.Read<{prop.Type}>(value);"}" : $"({prop.Type}) value")}; break; }}"))}
                default: return false;
            }}

            return true;
        }}

        RedisValue IRedisCacheObjectAdapter<{type.Name}>.GetValue({type.Name} instance, string propertyName)
        {{
            return propertyName switch
            {{
{string.Join('\n', resolvedProps.Select(prop => $"                nameof({type.Name}.{prop.Name}) => ({nameof(RedisValue)}) {(prop.Formatter != null ? $"{prop.Formatter + $".Instance.Write(instance.{prop.Name})"}" : $"instance.{prop.Name}")},"))}
                _ => default
            }};
        }}
    }}
}}", Encoding.UTF8);

                var fileName = $"{type.Name}Adapter.g.cs";
                GeneratedTypes.Add(typeFullQualifiedName);
                ctx.AddSource(fileName, sourceText);
            }
        }

        private static INamedTypeSymbol Transform(GeneratorSyntaxContext generatorSyntaxContext, CancellationToken cancellationToken)
        {
            var classDeclaration = generatorSyntaxContext.Node as ClassDeclarationSyntax;
            var classSymbol = generatorSyntaxContext.SemanticModel.GetDeclaredSymbol(classDeclaration!, cancellationToken: cancellationToken);
            return classSymbol;
        }

        private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            if (!(syntaxNode is ClassDeclarationSyntax classDeclaration))
                return false;

            if (!classDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword))
                return false;
            
            if (!classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword))
                return false;
            
            var baseList = classDeclaration.BaseList;
            if (baseList == null)
                return false;

            var types = baseList.Types;
            if (types.Count == 0)
                return false;

            foreach (var type in types)
            {
                if (!(type.Type is IdentifierNameSyntax identifier))
                    continue;

                if (!identifier.Identifier.Text.Equals(nameof(IRedisCacheObject), StringComparison.Ordinal))
                    continue;

                return true;
            }

            return false;
        }

        private static IPropertySymbol[] GetPropertySymbols(ITypeSymbol typeSymbol)
        {
            Memory<IPropertySymbol> props = new IPropertySymbol[1024];
            var lastIndex = -1;
            foreach (var propSymbol in typeSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                if (propSymbol.DeclaredAccessibility != Accessibility.Public)
                    continue;
                if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
                    continue;

                props.Span[++lastIndex] = propSymbol;
            }

            var baseType = typeSymbol.BaseType;
            while (baseType != null)
            {
                foreach (var propSymbol in baseType.GetMembers().OfType<IPropertySymbol>())
                {
                    if (propSymbol.DeclaredAccessibility != Accessibility.Public)
                        continue;
                    if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
                        continue;

                    var exists = false;
                    for (var i = 0; i < lastIndex + 1; i++)
                    {
                        exists = props.Span[i].Name.Equals(propSymbol.Name, StringComparison.Ordinal);
                        if (exists)
                            break;
                    }

                    if (!exists)
                        props.Span[++lastIndex] = propSymbol;
                }

                baseType = baseType.BaseType;
            }

            if (lastIndex == -1)
                return Array.Empty<IPropertySymbol>();

            props = props[..(lastIndex + 1)];
            return props.ToArray();
        }
    }
}